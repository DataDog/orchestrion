name: Tests
on:
  pull_request:
    branches: ['**']
  merge_group:
    branches: [main]
  push:
    branches: [main]
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions: read-all

jobs:
  ##############################################################################
  # Run all the code generators; and refresh the LICENSES-3rdparty.csv file
  generate:
    runs-on: ubuntu-latest
    name: Run all generators
    outputs:
      has-patch: ${{ steps.is-tree-dirty.outputs.result }}
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
      - name: Setup go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5
        with:
          go-version: stable
          cache-dependency-path: '**/go.mod'

      - name: Run 'go generate ./...'
        run: |-
          mkdir -p ${GOCOVERDIR}
          go generate ./...
          go -C _integration-tests generate ./...
        env:
          GOFLAGS: -covermode=atomic -coverpkg=github.com/datadog/orchestrion/...
          GOCOVERDIR: ${{ github.workspace }}/coverage
      - name: Consolidate coverage report
        if: always() && github.event_name != 'merge_group'
        run: go tool covdata textfmt -i ./coverage -o ./coverage/generator.out
      - name: Upload coverage report
        # We want this even if the tests failed
        if: always() && github.event_name != 'merge_group'
        uses: codecov/codecov-action@e28ff129e5465c2c0dcc6f003fc735cb6ae0c673 # v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: ${{ runner.os }},${{ runner.arch }},generator
          file: ./coverage/generator.out
          name: Generators

      - name: Run 'go mod tidy'
        # Don't run for push, it's not necessary
        if: github.event_name != 'push'
        run: find . -iname go.mod -execdir go mod tidy \;

      - name: Refresh LICENSE-3rdparty.csv
        run: ./tools/make-licenses.sh
        env:
          TMPDIR: ${{ runner.temp }}

      - name: Check if working tree is dirty
        # Don't run for push, it's not necessary
        if: github.event_name != 'push'
        id: is-tree-dirty
        run: |-
          git add .
          git diff --staged --patch --exit-code > .repo.patch || echo "result=true" >> ${GITHUB_OUTPUT}
      - name: Upload patch
        if: github.event_name != 'push' && steps.is-tree-dirty.outputs.result == 'true'
        uses: actions/upload-artifact@834a144ee995460fba8ed112a2fc961b36a5ec5a # v4
        with:
          name: repo.patch
          path: .repo.patch
      - name: Fail build if working tree is dirty
        if: github.event_name == 'push' && steps.is-tree-dirty.outputs.result == 'true'
        run: |-
          echo "::error::Files have been modified by 'go generate ./...' (see logs)."
          cat .repo.patch
          exit 1
  ##############################################################################
  # If the generators changed anything, and we can update the PR, then we'll
  # proactively do it with the mutator token.
  self-mutation:
    needs: generate
    runs-on: ubuntu-latest
    name: Update PR with generated files
    if: always() && needs.generate.outputs.has-patch == 'true' && github.event_name == 'pull_request' && (github.event.pull_request.head.repo.full_name == github.repository || github.event.pull_request.maintainer_can_modify)
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
        with:
          ref: ${{ github.event.pull_request.head.ref }}
          repository: ${{ github.event.pull_request.head.repo.full_name }}
      - name: Download patch
        uses: actions/download-artifact@fa0a91b85d4f404e444e00e005971372dc801d16 # v4
        with:
          name: repo.patch
          path: ${{ runner.temp }}
      - name: Apply patch
        run: |-
          [ -s '${{ runner.temp }}/.repo.patch' ] && git apply '${{ runner.temp }}/.repo.patch' || echo 'Empty patch. Skipping.'
      # We use ghcommit to create signed commits directly using the GitHub API
      - name: Push changes
        uses: planetscale/ghcommit-action@c7915d6c18d5ce4eb42b0eff3f10a29fe0766e4c # v0.1.44
        with:
          commit_message: "chore: update generated files"
          repo: ${{ github.event.pull_request.head.repo.full_name }}
          branch: ${{ github.event.pull_request.head.ref }}
        env:
          GITHUB_TOKEN: ${{ secrets.MUTATOR_GITHUB_TOKEN }}

  ##############################################################################
  # Run the various linters we have set up...
  lint:
    needs: generate
    runs-on: ubuntu-latest
    name: Go Linters
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
      - name: Setup go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5
        with:
          go-version: stable
          cache-dependency-path: "**/go.mod"
      - name: golangci-lint
        uses: golangci/golangci-lint-action@aaa42aa0628b4ae2578232a66b541047968fac86 # v6
        with:
          version: v1.52.2
          skip-cache: true # actions/setup-go has already done this
      - name: Verify license headers
        run: go run tools/headercheck/header_check.go
      - name: vet
        run: go vet ./...

  ##############################################################################
  # Verify all GitHub workflows have hash-pinned actions
  lint-workflows:
    runs-on: ubuntu-latest
    name: GitHub Workflow Linters
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
      - name: Ensure SHA pinned actions
        uses: zgosalvez/github-actions-ensure-sha-pinned-actions@b88cd0aad2c36a63e42c71f81cb1958fed95ac87 # v3

  ##############################################################################
  # Run all unit tests with coverage enabled
  unit-tests:
    needs: generate
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        go-version: [oldstable, stable]
    name: Unit tests (go ${{ matrix.go-version }})
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
      - name: Checkout Go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5
        with:
          go-version: ${{ matrix.go-version }}
          cache-dependency-path: "**/go.mod"
      - name: Run unit tests
        run: |-
          mkdir -p coverage
          go test -shuffle=on -cover -covermode=atomic -coverpkg=./... -coverprofile=${{ github.workspace }}/coverage/unit.out -race ./...
          go -C _integration-tests test -shuffle=on -cover -covermode=atomic -coverpkg=./...,github.com/datadog/orchestrion/... -coverprofile=${{ github.workspace }}/coverage/integration.out -race ./...
      - name: Determine simple go version
        if: always() && github.event_name != 'merge_group'
        id: simple-go-version
        run: echo "version=$(go version | cut -d' ' -f3 | grep -oE '\d+\.\d+')" >> "${GITHUB_OUTPUT}"
        shell: bash
      - name: Upload coverage report
        # We want this even if the tests failed
        if: always() && github.event_name != 'merge_group'
        uses: codecov/codecov-action@e28ff129e5465c2c0dcc6f003fc735cb6ae0c673 # v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: go${{ steps.simple-go-version.outputs.version }},${{ runner.os }},${{ runner.arch }},unit
          files: ./coverage/unit.out,./coverage/integration.out
          name: Unit Tests (go ${{ matrix.go-version }})

  ##############################################################################
  # Run all integration tests and gather extensive coverage
  integration-tests:
    needs: generate
    strategy:
      fail-fast: false
      matrix:
        runs-on: [macos, ubuntu, windows]
        go-version: [oldstable, stable]
        build-mode: [DRIVER]
        include:
          # Alternate build modes (only on ubuntu, latest go; to save CI time)
          - runs-on: ubuntu
            go-version: oldstable
            build-mode: TOOLEXEC
          - runs-on: ubuntu
            go-version: oldstable
            build-mode: GOFLAGS
    runs-on: ${{ matrix.runs-on }}-latest
    name: Integration tests (go ${{ matrix.go-version }}, ${{ matrix.runs-on }}, ${{ matrix.build-mode }})
    steps:
      - name: Checkout
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
      - name: Setup go
        uses: actions/setup-go@0a12ed9d6a96ab950c8f026ed9f722fe0da7ef32 # v5
        with:
          go-version: ${{ matrix.go-version }}
          cache-dependency-path: "**/go.mod"
      - name: Setup python
        uses: actions/setup-python@39cd14951b08e74b54015e9e001cdefcf80e669f # v5
        with:
          python-version: 3.x
          cache: pip
          cache-dependency-path: _integration-tests/utils/agent/requirements.txt
      - name: Install python dependencies
        run: pip install -r _integration-tests/utils/agent/requirements.txt
      - name: Build orchestrion binary
        run: go build -cover -covermode=atomic -coverpkg="./..." -o="bin/orchestrion.exe" .
      - name: Run Integration Tests
        shell: bash
        run: |-
          mkdir -p "${GOCOVERDIR}"
          case "${{ matrix.build-mode }}" in
          "DRIVER")
            bin/orchestrion.exe go -C=_integration-tests test -shuffle=on ./...
            ;;
          "TOOLEXEC")
            go -C=_integration-tests test -shuffle=on -toolexec="${{ github.workspace }}/bin/orchestrion.exe toolexec" ./...
            ;;
          "GOFLAGS")
            export GOFLAGS="'-toolexec=${{ github.workspace }}/bin/orchestrion.exe toolexec' ${GOFLAGS}"
            go -C=_integration-tests test -shuffle=on ./...
            ;;
          *)
            echo "Unknown build mode: ${{ matrix.build-mode }}"
            exit 1
            ;;
          esac
        env:
          GOCOVERDIR: ${{ github.workspace }}/coverage/raw
          GOFLAGS: -tags=integration,buildtag # Globally set build tags (buildtag is used by the dd-span test)
      - name: Consolidate coverage report
        if: github.event_name != 'merge_group'
        run: go tool covdata textfmt -i ./coverage/raw -o ./coverage/integration.out
      - name: Determine simple go version
        if: github.event_name != 'merge_group'
        id: simple-go-version
        run: echo "version=$(go version | cut -d' ' -f3 | grep -oE '\d+\.\d+')" >> "${GITHUB_OUTPUT}"
        shell: bash
      - name: Upload coverage report
        if: github.event_name != 'merge_group'
        uses: codecov/codecov-action@e28ff129e5465c2c0dcc6f003fc735cb6ae0c673 # v4
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          flags: go${{ steps.simple-go-version.outputs.version }},${{ runner.os }},${{ runner.arch }},integration
          files: ./coverage/integration.out
          name: Integration Tests (go ${{ matrix.go-version }}, ${{ matrix.runs-on }}, ${{ matrix.build-mode }})

  ##############################################################################
  # Assert everything is complete. This simplifies branch protection settings
  # and allows us to have one single trigger for CodeCov reporting.
  complete:
    runs-on: ubuntu-latest
    name: Complete
    needs:
      - generate
      - lint
      - lint-workflows
      - unit-tests
      - integration-tests
    if: '!cancelled()'
    steps:
      - name: Checkout
        if: github.event_name == 'pull_request'
        uses: actions/checkout@692973e3d937129bcbf40652eb9f2f61becf3332 # v4
      - name: Download codecov CLI
        if: github.event_name == 'pull_request'
        run: |-
          set -euo pipefail

          curl -fSsL "${BASE_URL}" -o "./codecov"
          curl -fSsL "${BASE_URL}.SHA256SUM" -o "./codecov.SHA256SUM"
          curl -fSsL "${BASE_URL}.SHA256SUM.sig" -o "./codecov.SHA256SUM.sig"

          # Import the CodeCov security key
          curl -fSsL "https://keybase.io/codecovsecurity/pgp_keys.asc" | gpg --no-default-keyring --keyring trustedkeys.gpg --import

          # Verify the downloaded binary matches expected signatures
          gpgv "./codecov.SHA256SUM.sig" "./codecov.SHA256SUM"
          shasum -a 256 -c "./codecov.SHA256SUM"

          chmod a+x "./codecov"
        env:
          BASE_URL: https://cli.codecov.io/latest/linux${{ runner.arch == 'ARM64' && '-arm64' || '' }}/codecov
        working-directory: ${{ runner.temp }}
      - name: Trigger CodeCov notifications
        if: github.event_name == 'pull_request'
        run: |-
          ${{ runner.temp }}/codecov send-notifications                         \
            --token="${CODECOV_TOKEN}"                                          \
            --fail-on-error                                                     \
            --slug=${{ github.event.pull_request.base.repo.full_name }}         \
            --sha=${{ github.event.pull_request.head.sha }}
        env:
          CODECOV_TOKEN: ${{ secrets.CODECOV_TOKEN }}
      - name: Done
        if: needs.lint.result == 'success' && needs.lint-workflows.result == 'success' && needs.unit-tests.result == 'success' && needs.integration-tests.result == 'success'
        run: echo "OK"
      - name: Done
        if: needs.lint.result != 'success' || needs.lint-workflows.result != 'success' || needs.unit-tests.result != 'success' || needs.integration-tests.result != 'success'
        run: |-
          echo "Failed!"
          exit 1

