// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2023-present Datadog, Inc.

package main

import (
	"bytes"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"path"
	"strings"

	"github.com/charmbracelet/lipgloss"
	"github.com/datadog/orchestrion/internal/ensure"
	"github.com/datadog/orchestrion/internal/log"
	"github.com/datadog/orchestrion/internal/version"
	"github.com/dave/jennifer/jen"
	"golang.org/x/term"
)

const (
	orchestrionImportPath = "github.com/datadog/orchestrion"
	orchestrionToolGo     = "orchestrion.tool.go"
	envVarCheckedGoMod    = "DD_ORCHESTRION_IS_GOMOD_VERSION"
	envValTrue            = "true"
)

var (
	errNoGoMod           = errors.New("`go mod GOMOD` returned a blank string")
	requiredVersionError error // Whether the go.mod version check succeeded
)

// autoPinOrchestrion automatically runs `pinOrchestrion` if the necessary
// requirements are not already met. It prints messages to `os.Stderr` to inform
// the user about what is going on.
func autoPinOrchestrion() {
	if requiredVersionError == nil {
		// Nothing to do!
		return
	}

	var (
		box       = lipgloss.NewStyle()
		stylePath = lipgloss.NewStyle()
		styleFile = lipgloss.NewStyle()
		styleCmd  = lipgloss.NewStyle()
	)
	if term.IsTerminal(int(os.Stderr.Fd())) {
		box = box.Border(lipgloss.RoundedBorder()).
			BorderForeground(lipgloss.ANSIColor(1)).
			Padding(1, 2)
		if w, _, err := term.GetSize(int(os.Stderr.Fd())); err == nil {
			box.Width(w - box.GetHorizontalMargins() - box.GetHorizontalBorderSize())
		}

		stylePath = stylePath.Foreground(lipgloss.ANSIColor(4)).Underline(true)
		styleFile = styleFile.Foreground(lipgloss.ANSIColor(2)).Underline(true)
		styleCmd = styleCmd.Foreground(lipgloss.ANSIColor(5)).Bold(true).Underline(true)
	} else {
		fmt.Fprintf(os.Stderr, "Version check error: %v\n", requiredVersionError)
	}

	var builder strings.Builder
	builder.WriteString(lipgloss.NewStyle().Bold(true).Foreground(lipgloss.ANSIColor(3)).Render("Warning:"))
	builder.WriteRune(' ')
	builder.WriteString(stylePath.Render(orchestrionImportPath))
	builder.WriteString(" is not present in your ")
	builder.WriteString(styleFile.Render("go.mod"))
	builder.WriteString(" file.\nIn order to ensure build reliability and reproductibility, orchestrion")
	builder.WriteString(" will now add itself in your ")
	builder.WriteString(styleFile.Render("go.mod"))
	builder.WriteString(" file by:\n\n\t1. creating a new file named ")
	builder.WriteString(styleFile.Render(orchestrionToolGo))
	builder.WriteString("\n\t2. running ")
	builder.WriteString(styleCmd.Render(fmt.Sprintf("go get %s@%s", orchestrionImportPath, version.Tag)))
	builder.WriteString("\n\t3. running ")
	builder.WriteString(styleCmd.Render("go mod tidy"))
	builder.WriteString("\n\nYou should commit the resulting changes into your source control system.")

	message := builder.String()
	fmt.Fprintln(os.Stderr, box.Render(message))

	if err := pinOrchestrion(); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to pin orchestrion in go.mod: %v\n", err)
		os.Exit(1)
	}

	requiredVersionError = nil
}

func pinOrchestrion() error {
	goMod := os.Getenv("GOMOD")
	if goMod == "" {
		cmd := exec.Command("go", "env", "GOMOD")
		var stdout bytes.Buffer
		cmd.Stdout = &stdout
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("runnning %q: %w", cmd.Args, err)
		}
		goMod = strings.TrimSpace(stdout.String())
	}
	if goMod == "" {
		wd, _ := os.Getwd()
		return fmt.Errorf("in %q: %w", wd, errNoGoMod)
	}

	code := jen.NewFile("tools")
	code.HeaderComment(strings.Join([]string{
		"// Code generated by `orchestrion pin`; DO NOT EDIT.",
		"",
		"// This file is generated by `orchestrion pin`, and is used to include a blank import of the",
		"// orchestrion package(s) so that `go mod tidy` does not remove the requirements from go.mod.",
		"// This file should be checked into source control.",
	}, "\n"))
	code.PackageComment("//go:build tools")
	code.Anon(orchestrionImportPath)

	// We write into a temporary file, and then rename it in place. This reduces the risk of
	// concurrent calls resulting in partial writes, etc...
	toolFile := path.Join(goMod, "..", orchestrionToolGo)
	tmpFile, err := os.CreateTemp(path.Dir(toolFile), "orchestrion.tool.go.*")
	if err != nil {
		return fmt.Errorf("creating temporary %q: %w", tmpFile.Name(), err)
	}
	err = code.Render(tmpFile)
	tmpFile.Close()
	if err != nil {
		return fmt.Errorf("writing to %q: %w", tmpFile.Name(), err)
	}
	if err = os.Rename(tmpFile.Name(), toolFile); err != nil {
		return fmt.Errorf("renaming %q to %q: %w", tmpFile.Name(), toolFile, err)
	}

	pkgVersion := fmt.Sprintf("%s@%s", orchestrionImportPath, version.Tag)
	if err := exec.Command("go", "get", pkgVersion).Run(); err != nil {
		return fmt.Errorf("running `go get %s`: %w", pkgVersion, err)
	}

	if err := exec.Command("go", "mod", "tidy").Run(); err != nil {
		return fmt.Errorf("running `go mod tidy`: %w", err)
	}

	return nil
}

func init() {
	if os.Getenv(envVarCheckedGoMod) == envValTrue {
		// A parent process has already done the check for us!!
		return
	}

	if requiredVersionError = ensure.RequiredVersion(); requiredVersionError != nil {
		log.Tracef("Failed to detect required version of orchestrion from go.mod: %v\n", requiredVersionError)
		if wd, err := os.Getwd(); err == nil {
			log.Tracef("Working directory: %q\n", wd)
		}
		log.Tracef("GOMOD=%s\n", os.Getenv("GOMOD"))
	} else {
		os.Setenv(envVarCheckedGoMod, envValTrue)
	}
}
