%YAML 1.1
---
http-default:
  options:
    injections: &injections
      - join-point:
          function-body:
            function:
              - signature:
                  args:
                    - 'net/http.ResponseWriter'
                    - '*net/http.Request'
        advice:
          - prepend-statements:
              imports:
                instrument: github.com/datadog/orchestrion/instrument
              template: |-
                {{- $arg := .Function.Argument 1 -}}
                {{- $name := .Function.Name -}}
                {{$arg}} = instrument.HandleHeader({{$arg}})
                instrument.Report({{$arg}}.Context(), instrument.EventStart{{with $name}}, "name", {{printf "%q" .}}{{end}}, "verb", {{$arg}}.Method)
                defer instrument.Report({{$arg}}.Context(), instrument.EventEnd{{with $name}}, "name", {{printf "%q" .}}{{end}}, "verb", {{$arg}}.Method)
  source: &httpSource |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    func handle(w http.ResponseWriter, r *http.Request) {
      data, err := io.ReadAll(r.Body)
      if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(err.Error()))
        return
      }
      defer r.Body.Close()
      w.WriteHeader(http.StatusOK)
      w.Write(data)
    }
  expected:
    modified: true
    references: &references
      github.com/datadog/orchestrion/instrument: true # Orchestrion is imported synthetically
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "github.com/datadog/orchestrion/instrument"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
        //dd:startinstrument
        {
          r = instrument.HandleHeader(r)
          instrument.Report(r.Context(), instrument.EventStart, "name", "handle", "verb", r.Method)
          defer instrument.Report(r.Context(), instrument.EventEnd, "name", "handle", "verb", r.Method)
        }
        //dd:endinstrument
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

http-anonymous-handler:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr: ":8085",
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          data, err := io.ReadAll(r.Body)
          if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            w.Write([]byte(err.Error()))
            return
          }
          defer r.Body.Close()
          w.WriteHeader(http.StatusOK)
          w.Write(data)
        }),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "github.com/datadog/orchestrion/instrument"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr: ":8085",
          Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            //dd:startinstrument
            {
              r = instrument.HandleHeader(r)
              instrument.Report(r.Context(), instrument.EventStart, "verb", r.Method)
              defer instrument.Report(r.Context(), instrument.EventEnd, "verb", r.Method)
            }
            //dd:endinstrument
            data, err := io.ReadAll(r.Body)
            if err != nil {
              w.WriteHeader(http.StatusBadRequest)
              w.Write([]byte(err.Error()))
              return
            }
            defer r.Body.Close()
            w.WriteHeader(http.StatusOK)
            w.Write(data)
          }),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

http-no-arg-name:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    func handle(http.ResponseWriter, *http.Request) {
    }
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "log"
        "net/http"

        "github.com/datadog/orchestrion/instrument"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(_ http.ResponseWriter, __argument__1 *http.Request) {
        //dd:startinstrument
        {
          __argument__1 = instrument.HandleHeader(__argument__1)
          instrument.Report(__argument__1.Context(), instrument.EventStart, "name", "handle", "verb", __argument__1.Method)
          defer instrument.Report(__argument__1.Context(), instrument.EventEnd, "name", "handle", "verb", __argument__1.Method)
        }
        //dd:endinstrument
      }

http-lineInfo:
  options:
    injections: *injections
    preservelineinfo: true
  source: *httpSource
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:12
      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
      //line <generated>:1
        //dd:startinstrument
        {
          r = instrument.HandleHeader(r)
          instrument.Report(r.Context(), instrument.EventStart, "name", "handle", "verb", r.Method)
          defer instrument.Report(r.Context(), instrument.EventEnd, "name", "handle", "verb", r.Method)
        }
        //dd:endinstrument
      //line input.go:24
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

http-ignored:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    //dd:ignore
    func handle(w http.ResponseWriter, r *http.Request) {
      data, err := io.ReadAll(r.Body)
      if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(err.Error()))
        return
      }
      defer r.Body.Close()
      w.WriteHeader(http.StatusOK)
      w.Write(data)
    }
  expected:
    modified: false

http-server:
  options:
    injections:
      - join-point:
          struct-literal:
            type: net/http.Server
            field: Handler
        advice:
          - wrap-expression:
              imports:
                instrument: github.com/datadog/orchestrion/instrument
              template: |-
                //dd:startwrap
                instrument.WrapHandler({{ . }})
                //dd:endwrap
    preservelineinfo: true
  source: *httpSource
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument: true
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:12
      func main() {
        s := &http.Server{
          Addr: ":8085",
          Handler:
      //line <generated>:1
          //dd:startwrap
          instrument.WrapHandler(
      //line input.go:15
            http.HandlerFunc(handle)),
          //dd:endwrap
        }
      //line input.go:17
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

change-return-value:
  options:
    injections:
      - join-point:
          function-body:
            function:
              - signature:
                  returns:
                    - any
                    - error
        advice:
          - prepend-statements:
              imports:
                log: log
              template: |-
                {{- $ret := .Function.Returns 1 -}}
                defer func(){
                  if {{$ret}} != nil {
                    log.Println("error in {{.Function.Name}}:", {{$ret}})
                  }
                }()
  source: |
    package main

    import (
      "errors"
      "log"
    )

    func test() (interface{}, error) {
      log.Println("Running test function...")
      return nil, errors.ErrUnsupported
    }
  expected:
    modified: true
    source: |
      package main

      import (
        "errors"
        "log"
      )

      func test() (_ interface{}, __returns__1 error) {
        //dd:startinstrument
        {
          defer func() {
            if __returns__1 != nil {
              log.Println("error in test:", __returns__1)
            }
          }()
        }
        //dd:endinstrument
        log.Println("Running test function...")
        return nil, errors.ErrUnsupported
      }

chi5-newroute:
  options:
    preservelineinfo: true
    injections:
      - join-point:
          assignment-of:
            function-call: github.com/go-chi/chi/v5.NewRouter
        advice:
          - add-comment: '//dd:instrumented'
          - append-statements:
              template: '{{.Assignment.Variable}}.Use(instrument.ChiV5Middleware())'
              imports:
                instrument: github.com/datadog/orchestrion/instrument
  source: |
    package main

    import (
      "context"
      "log"
      "net/http"
      "time"

      "github.com/go-chi/chi/v5"
      "orchestrion/integration"
    )

    func main() {
      router := chi.NewRouter()
      router.Get("/", func(w http.ResponseWriter, _ *http.Request) {
        w.Write([]byte("Hello World!"))
      })
      s := &http.Server{
        Addr:    ":8080",
        Handler: router,
      }
      integration.OnSignal(func() {
        ctx, _ := context.WithTimeout(context.Background(), time.Second)
        s.Shutdown(ctx)
      })
      log.Print(s.ListenAndServe())
    }
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument: true
    source: |
      package main

      import (
        "context"
        "log"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5"
        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:13
      func main() {
        //dd:instrumented
        router := chi.NewRouter()
      //line <generated>:1
        //dd:startinstrument
        {
          router.Use(instrument.ChiV5Middleware())
        }
        //dd:endinstrument
      //line input.go:15
        router.Get("/", func(w http.ResponseWriter, _ *http.Request) {
          w.Write([]byte("Hello World!"))
        })
        s := &http.Server{
          Addr:    ":8080",
          Handler: router,
        }
        integration.OnSignal(func() {
          ctx, _ := context.WithTimeout(context.Background(), time.Second)
          s.Shutdown(ctx)
        })
        log.Print(s.ListenAndServe())
      }

directive:
  options:
    preservelineinfo: true
    injections:
      - join-point:
          function-body:
            function:
              - receives: context.Context
              - directive: 'dd:span'
        advice:
          - prepend-statements:
              imports:
                event: github.com/datadog/orchestrion/instrument/event
                instrument: github.com/datadog/orchestrion/instrument
              template: |-
                {{- $ctx := .FindArgument "context.Context" -}}
                {{- $name := .Function.Name -}}
                instrument.Report({{$ctx}}, event.EventStart{{with $name}}, "name", {{printf "%q" .}}{{end}}
                {{- range .DirectiveArgs "dd:span" -}}
                  , {{printf "%q" .Key}}, {{printf "%q" .Value}}
                {{- end -}})
                defer instrument.Report({{$ctx}}, event.EventEnd{{with $name}}, "name", {{printf "%q" .}}{{end}}
                {{- range .DirectiveArgs "dd:span" -}}
                  , {{printf "%q" .Key}}, {{printf "%q" .Value}}
                {{- end -}})
  source: |
    package test

    //dd:span foo:bar baz:qux
    func outer(ctx context.Context) {
      //dd:span
      inner := func(c context.Context) {
        panic("Not implemented")
      }
      inner(ctx)
    }
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument/event: true
      github.com/datadog/orchestrion/instrument: true
    source: |
      package test

      //line <generated>:1
      import (
        "github.com/datadog/orchestrion/instrument"
        "github.com/datadog/orchestrion/instrument/event"
      )

      //dd:span foo:bar baz:qux
      //line input.go:4
      func outer(ctx context.Context) {
      //line <generated>:1
        //dd:startinstrument
        {
          instrument.Report(ctx, event.EventStart, "name", "outer", "foo", "bar", "baz", "qux")
          defer instrument.Report(ctx, event.EventEnd, "name", "outer", "foo", "bar", "baz", "qux")
        }
        //dd:endinstrument
        //dd:span
      //line input.go:6
        inner := func(c context.Context) {
      //line <generated>:1
          //dd:startinstrument
          {
            instrument.Report(c, event.EventStart)
            defer instrument.Report(c, event.EventEnd)
          }
          //dd:endinstrument
      //line input.go:7
          panic("Not implemented")
        }
        inner(ctx)
      }

grpc-client:
  options:
    preservelineinfo: true
    injections:
      - join-point:
          function-call: google.golang.org/grpc.Dial
        advice:
          - append-args:
              - imports: &imports
                  instrument: github.com/datadog/orchestrion/instrument
                template: instrument.GRPCStreamClientInterceptor()
              - imports: *imports
                template: instrument.GRPCUnaryClientInterceptor()
      - join-point:
          function-call: google.golang.org/grpc.NewServer
        advice:
          - append-args:
              - imports: *imports
                template: instrument.GRPCStreamServerInterceptor()
              - imports: *imports
                template: instrument.GRPCUnaryServerInterceptor()

  source: |
    package main

    import (
      "log"
      "net"

      "google.golang.org/grpc"
    )

    func grpcClient() {
      conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure())
      if err != nil {
        log.Fatal(err)
      }
      defer conn.Close()
    }

    func grpcServer() {
      ln, err := net.Listen("tcp", ":50051")
      if err != nil {
        log.Fatal(err)
      }

      s := grpc.NewServer(grpc.EmptyServerOption{})
      if err := s.Serve(ln); err != nil {
        log.Fatalf("failed to serve: %v", err)
      }
    }
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument: true
    source: |
      package main

      import (
        "log"
        "net"

        "google.golang.org/grpc"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:10
      func grpcClient() {
        conn, err := grpc.Dial("localhost:50051", grpc.WithInsecure(),
      //line <generated>:1
          instrument.GRPCStreamClientInterceptor(), instrument.GRPCUnaryClientInterceptor())
      //line input.go:12
        if err != nil {
          log.Fatal(err)
        }
        defer conn.Close()
      }

      func grpcServer() {
        ln, err := net.Listen("tcp", ":50051")
        if err != nil {
          log.Fatal(err)
        }

        s := grpc.NewServer(grpc.EmptyServerOption{},
      //line <generated>:1
          instrument.GRPCStreamServerInterceptor(), instrument.GRPCUnaryServerInterceptor())
      //line input.go:25
        if err := s.Serve(ln); err != nil {
          log.Fatalf("failed to serve: %v", err)
        }
      }
