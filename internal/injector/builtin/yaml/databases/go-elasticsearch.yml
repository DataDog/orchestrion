# Unless explicitly stated otherwise all files in this repository are licensed
# under the Apache License Version 2.0.
# This product includes software developed at Datadog (https://www.datadoghq.com/).
# Copyright 2023-present Datadog, Inc.
---
# yaml-language-server: $schema=../../../../../docs/static/schema.json
meta:
  name: github.com/elastic/go-elasticsearch
  description: The official Go client for Elasticsearch
  icon: database

aspects:
  - id: Wrap elasticsearch.Config value (v6)
    join-point:
      struct-literal:
        type: github.com/elastic/go-elasticsearch/v6.Config
        match: value-only
    advice:
      - wrap-expression:
          imports:
            elasticsearch: github.com/elastic/go-elasticsearch/v6
            elastictrace: gopkg.in/DataDog/dd-trace-go.v1/contrib/elastic/go-elasticsearch.v6
          template: |-
            func(cfg elasticsearch.Config) elasticsearch.Config {            
              if cfg.Transport == nil {
                cfg.Transport = elastictrace.NewRoundTripper()
              } else {
                base := cfg.Transport
                cfg.Transport = elastictrace.NewRoundTripper(elastictrace.WithTransport(base))
              }
              return cfg
            }({{ . }})

  - id: Wrap elasticsearch.Config pointer (v6)
    join-point:
      struct-literal:
        type: github.com/elastic/go-elasticsearch/v6.Config
        match: pointer-only
    advice:
      - wrap-expression:
          imports:
            elasticsearch: github.com/elastic/go-elasticsearch/v6
            elastictrace: gopkg.in/DataDog/dd-trace-go.v1/contrib/elastic/go-elasticsearch.v6
          template: |-
            func(cfg *elasticsearch.Config) *elasticsearch.Config {            
              if cfg.Transport == nil {
                cfg.Transport = elastictrace.NewRoundTripper()
              } else {
                base := cfg.Transport
                cfg.Transport = elastictrace.NewRoundTripper(elastictrace.WithTransport(base))
              }
              return cfg
            }({{ . }})

  - id: Wrap elasticsearch.Config value (v7)
    join-point:
      struct-literal:
        type: github.com/elastic/go-elasticsearch/v7.Config
        match: value-only
    advice:
      - wrap-expression:
          imports:
            elasticsearch: github.com/elastic/go-elasticsearch/v7
            elastictrace: gopkg.in/DataDog/dd-trace-go.v1/contrib/elastic/go-elasticsearch.v6
          template: |-
            func(cfg elasticsearch.Config) elasticsearch.Config {            
              if cfg.Transport == nil {
                cfg.Transport = elastictrace.NewRoundTripper()
              } else {
                base := cfg.Transport
                cfg.Transport = elastictrace.NewRoundTripper(elastictrace.WithTransport(base))
              }
              return cfg
            }({{ . }})

  - id: Wrap elasticsearch.Config pointer (v7)
    join-point:
      struct-literal:
        type: github.com/elastic/go-elasticsearch/v7.Config
        match: pointer-only
    advice:
      - wrap-expression:
          imports:
            elasticsearch: github.com/elastic/go-elasticsearch/v7
            elastictrace: gopkg.in/DataDog/dd-trace-go.v1/contrib/elastic/go-elasticsearch.v6
          template: |-
            func(cfg *elasticsearch.Config) *elasticsearch.Config {
              // FIXME: if cfg.CACert != nil, then we know the call to elasticsearch.NewClient is gonna return an error.
              //  The workaround is to configure the certificate in the Transport instead, so should we continue modifying
              //  the config here so the user sees the error, or just silently return the unmodified code (which could be confusing
              //  for the user as they won't see traces)??
              //  NOTE: this problem exists for v7 and v8.
              if cfg.Transport == nil {
                cfg.Transport = elastictrace.NewRoundTripper()
              } else {
                base := cfg.Transport
                cfg.Transport = elastictrace.NewRoundTripper(elastictrace.WithTransport(base))
              }
              return cfg
            }({{ . }})

  - id: Wrap elasticsearch.Config value (v8)
    join-point:
      struct-literal:
        type: github.com/elastic/go-elasticsearch/v8.Config
        match: value-only
    advice:
      - wrap-expression:
          imports:
            elasticsearch: github.com/elastic/go-elasticsearch/v8
            elastictrace: gopkg.in/DataDog/dd-trace-go.v1/contrib/elastic/go-elasticsearch.v6
          template: |-
            func(cfg elasticsearch.Config) elasticsearch.Config {            
              if cfg.Transport == nil {
                cfg.Transport = elastictrace.NewRoundTripper()
              } else {
                base := cfg.Transport
                cfg.Transport = elastictrace.NewRoundTripper(elastictrace.WithTransport(base))
              }
              return cfg
            }({{ . }})

  - id: Wrap elasticsearch.Config pointer (v8)
    join-point:
      struct-literal:
        type: github.com/elastic/go-elasticsearch/v8.Config
        match: pointer-only
    advice:
      - wrap-expression:
          imports:
            elasticsearch: github.com/elastic/go-elasticsearch/v8
            elastictrace: gopkg.in/DataDog/dd-trace-go.v1/contrib/elastic/go-elasticsearch.v6
          template: |-
            func(cfg *elasticsearch.Config) *elasticsearch.Config {            
              if cfg.Transport == nil {
                cfg.Transport = elastictrace.NewRoundTripper()
              } else {
                base := cfg.Transport
                cfg.Transport = elastictrace.NewRoundTripper(elastictrace.WithTransport(base))
              }
              return cfg
            }({{ . }})
