%YAML 1.1
---
http-default:
  options:
    injections: &injections
      - join-point:
          function-body:
            function:
              - signature:
                  args:
                    - 'net/http.ResponseWriter'
                    - '*net/http.Request'
        advice:
          - prepend-statements:
              imports:
                instrument: github.com/datadog/orchestrion/instrument
              template: |-
                {{- $arg := FuncArgName 1 -}}
                {{- $name := FuncName -}}
                {{$arg}} = instrument.HandleHeader({{$arg}})
                instrument.Report({{$arg}}.Context(), instrument.EventStart{{with $name}}, "name", {{printf "%q" .}}{{end}}, "verb", {{$arg}}.Method)
                defer instrument.Report({{$arg}}.Context(), instrument.EventEnd{{with $name}}, "name", {{printf "%q" .}}{{end}}, "verb", {{$arg}}.Method)
  source: &httpSource |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    func handle(w http.ResponseWriter, r *http.Request) {
      data, err := io.ReadAll(r.Body)
      if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(err.Error()))
        return
      }
      defer r.Body.Close()
      w.WriteHeader(http.StatusOK)
      w.Write(data)
    }
  expected:
    modified: true
    references: &references
      github.com/datadog/orchestrion/instrument: true # Orchestrion is imported synthetically
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "github.com/datadog/orchestrion/instrument"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
        //dd:startinstrument
        {
          r = instrument.HandleHeader(r)
          instrument.Report(r.Context(), instrument.EventStart, "name", "handle", "verb", r.Method)
          defer instrument.Report(r.Context(), instrument.EventEnd, "name", "handle", "verb", r.Method)
        }
        //dd:endinstrument
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

http-anonymous-handler:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr: ":8085",
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          data, err := io.ReadAll(r.Body)
          if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            w.Write([]byte(err.Error()))
            return
          }
          defer r.Body.Close()
          w.WriteHeader(http.StatusOK)
          w.Write(data)
        }),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "github.com/datadog/orchestrion/instrument"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr: ":8085",
          Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            //dd:startinstrument
            {
              r = instrument.HandleHeader(r)
              instrument.Report(r.Context(), instrument.EventStart, "verb", r.Method)
              defer instrument.Report(r.Context(), instrument.EventEnd, "verb", r.Method)
            }
            //dd:endinstrument
            data, err := io.ReadAll(r.Body)
            if err != nil {
              w.WriteHeader(http.StatusBadRequest)
              w.Write([]byte(err.Error()))
              return
            }
            defer r.Body.Close()
            w.WriteHeader(http.StatusOK)
            w.Write(data)
          }),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

http-no-arg-name:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    func handle(http.ResponseWriter, *http.Request) {
    }
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "log"
        "net/http"

        "github.com/datadog/orchestrion/instrument"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(_ http.ResponseWriter, _1 *http.Request) {
        //dd:startinstrument
        {
          _1 = instrument.HandleHeader(_1)
          instrument.Report(_1.Context(), instrument.EventStart, "name", "handle", "verb", _1.Method)
          defer instrument.Report(_1.Context(), instrument.EventEnd, "name", "handle", "verb", _1.Method)
        }
        //dd:endinstrument
      }

http-lineInfo:
  options:
    injections: *injections
    preservelineinfo: true
  source: *httpSource
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:12
      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
      //line <generated>:1
        //dd:startinstrument
        {
          r = instrument.HandleHeader(r)
          instrument.Report(r.Context(), instrument.EventStart, "name", "handle", "verb", r.Method)
          defer instrument.Report(r.Context(), instrument.EventEnd, "name", "handle", "verb", r.Method)
        }
        //dd:endinstrument
      //line input.go:24
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

http-ignored:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"

      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    //dd:ignore
    func handle(w http.ResponseWriter, r *http.Request) {
      data, err := io.ReadAll(r.Body)
      if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(err.Error()))
        return
      }
      defer r.Body.Close()
      w.WriteHeader(http.StatusOK)
      w.Write(data)
    }
  expected:
    modified: false

http-server:
  options:
    injections:
      - join-point:
          struct-literal:
            type: net/http.Server
            field: Handler
        advice:
          - wrap-expression:
              imports:
                instrument: github.com/datadog/orchestrion/instrument
              template: |-
                //dd:startwrap
                instrument.WrapHandler({{ Expr }})
                //dd:endwrap
    preservelineinfo: true
  source: *httpSource
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument: true
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"

        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:12
      func main() {
        s := &http.Server{
          Addr: ":8085",
          Handler:
      //line <generated>:1
          //dd:startwrap
          instrument.WrapHandler(
      //line input.go:15
            http.HandlerFunc(handle)),
          //dd:endwrap
        }
      //line input.go:17
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

change-return-value:
  options:
    injections:
      - join-point:
          function-body:
            function:
              - signature:
                  returns:
                    - any
                    - error
        advice:
          - prepend-statements:
              imports:
                log: log
              template: |-
                {{- $ret := FuncReturnValue 1 -}}
                defer func(){
                  if {{$ret}} != nil {
                    log.Println("error in {{FuncName}}:", {{$ret}})
                  }
                }()
  source: |
    package main

    import (
      "errors"
      "log"
    )

    func test() (interface{}, error) {
      log.Println("Running test function...")
      return nil, errors.ErrUnsupported
    }
  expected:
    modified: true
    source: |
      package main

      import (
        "errors"
        "log"
      )

      func test() (_ret_0 interface{}, _ret_1 error) {
        //dd:startinstrument
        {
          defer func() {
            if _ret_1 != nil {
              log.Println("error in test:", _ret_1)
            }
          }()
        }
        //dd:endinstrument
        log.Println("Running test function...")
        return nil, errors.ErrUnsupported
      }

chi5-newroute:
  options:
    preservelineinfo: true
    injections:
      - join-point:
          assignment-of:
            function-call: github.com/go-chi/chi/v5.NewRouter
        advice:
          - add-comment: '//dd:instrumented'
          - append-statements:
              template: '{{AssignedVar}}.Use(instrument.ChiV5Middleware())'
              imports:
                instrument: github.com/datadog/orchestrion/instrument
  source: |
    package main

    import (
      "context"
      "log"
      "net/http"
      "time"

      "github.com/go-chi/chi/v5"
      "orchestrion/integration"
    )

    func main() {
      router := chi.NewRouter()
      router.Get("/", func(w http.ResponseWriter, _ *http.Request) {
        w.Write([]byte("Hello World!"))
      })
      s := &http.Server{
        Addr:    ":8080",
        Handler: router,
      }
      integration.OnSignal(func() {
        ctx, _ := context.WithTimeout(context.Background(), time.Second)
        s.Shutdown(ctx)
      })
      log.Print(s.ListenAndServe())
    }
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument: true
    source: |
      package main

      import (
        "context"
        "log"
        "net/http"
        "time"

        "github.com/go-chi/chi/v5"
        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:13
      func main() {
        //dd:instrumented
        router := chi.NewRouter()
      //line <generated>:1
        //dd:startinstrument
        {
          router.Use(instrument.ChiV5Middleware())
        }
        //dd:endinstrument
      //line input.go:15
        router.Get("/", func(w http.ResponseWriter, _ *http.Request) {
          w.Write([]byte("Hello World!"))
        })
        s := &http.Server{
          Addr:    ":8080",
          Handler: router,
        }
        integration.OnSignal(func() {
          ctx, _ := context.WithTimeout(context.Background(), time.Second)
          s.Shutdown(ctx)
        })
        log.Print(s.ListenAndServe())
      }
