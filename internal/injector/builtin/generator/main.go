// Unless explicitly stated otherwise all files in this repository are licensed
// under the Apache License Version 2.0.
// This product includes software developed at Datadog (https://www.datadoghq.com/).
// Copyright 2023-present Datadog, Inc.

package main

import (
	"crypto/sha512"
	"encoding/base64"
	"flag"
	"fmt"
	"io"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
	"golang.org/x/tools/go/packages"
	"gopkg.in/yaml.v3"
)

type globs []string

func main() {
	var (
		pkg     string
		glob    globs
		output  string
		deps    string
		docsDir string
		chomp   int
	)

	flag.StringVar(&pkg, "p", "", "package name")
	flag.Var(&glob, "i", "input files (glob syntax, can be set multiple times)")
	flag.StringVar(&output, "o", "", "output file")
	flag.StringVar(&deps, "d", "", "dependencies file")
	flag.StringVar(&docsDir, "docs", "", "directory to write documentation files to")
	flag.IntVar(&chomp, "C", 0, "number of leading path components to strip from matched file names")
	flag.Parse()

	if len(glob) == 0 {
		log.Fatalln("Missing -i option!")
	}

	matches, err := glob.glob()
	if err != nil {
		log.Fatalf("failed to process glob pattern(s) %s: %v\n", glob, err)
	}

	if len(matches) == 0 {
		log.Fatalf("no files matched pattern %q\n", glob)
	}
	// Ensure the files are sorted for determinism.
	sort.Strings(matches)

	if docsDir != "" {
		filepath.WalkDir(docsDir, func(path string, d fs.DirEntry, err error) error {
			if err != nil {
				return err
			}
			if d.IsDir() || filepath.Ext(path) != ".md" || strings.HasPrefix(filepath.Base(path), "_") {
				return nil
			}
			return os.Remove(path)
		})
	}

	var (
		depsFile      *jen.File
		injectedPaths = make(map[string]struct{})
	)
	if deps != "" {
		depsFile = jen.NewFile(pkg)
		depsFile.HeaderComment("Unless explicitly stated otherwise all files in this repository are licensed")
		depsFile.HeaderComment("under the Apache License Version 2.0.")
		depsFile.HeaderComment("This product includes software developed at Datadog (https://www.datadoghq.com/).")
		depsFile.HeaderComment("Copyright 2023-present Datadog, Inc.")
		depsFile.HeaderComment("")
		depsFile.HeaderComment(fmt.Sprintf("Code generated by %q; DO NOT EDIT.", "github.com/datadog/orchestion/internal/injector/builtin/generator "+strings.Join(os.Args[1:], " ")))
		depsFile.PackageComment("//go:build tools")
	}

	file := jen.NewFile(pkg)
	file.HeaderComment("Unless explicitly stated otherwise all files in this repository are licensed")
	file.HeaderComment("under the Apache License Version 2.0.")
	file.HeaderComment("This product includes software developed at Datadog (https://www.datadoghq.com/).")
	file.HeaderComment("Copyright 2023-present Datadog, Inc.")
	file.HeaderComment("")
	file.HeaderComment(fmt.Sprintf("Code generated by %q; DO NOT EDIT.", "github.com/datadog/orchestion/internal/injector/builtin/generator "+strings.Join(os.Args[1:], " ")))

	checksum := sha512.New()
	file.Comment("Aspects is the list of built-in aspects.")
	file.Var().Id("Aspects").Op("=").Index(jen.Op("...")).Qual("github.com/datadog/orchestrion/internal/injector/aspect", "Aspect").ValuesFunc(func(g *jen.Group) {
		for _, match := range matches {
			// Checksum header -- SOH <relative file name> STX
			writeAll(checksum, []byte(fmt.Sprintf("\x01%s\x02", match)))

			data, err := os.ReadFile(match)
			if err != nil {
				log.Fatalf("failed to read input file %q: %v\n", match, err)
			}

			// Checksum body -- <data> ETX
			writeAll(checksum, data)
			writeAll(checksum, []byte{'\x03'})

			var config ConfigurationFile
			if err := yaml.Unmarshal(data, &config); err != nil {
				log.Fatalf("failed to unmarshal input file %q: %v\n", match, err)
			}

			chomped := removeLeadingSegments(match, chomp)

			if docsDir != "" {
				if err := documentConfiguration(docsDir, chomped, &config); err != nil {
					log.Fatalf("failed to document aspects from %q: %v\n", match, err)
				}
			}

			for i, entry := range config.Aspects {
				item := g.Line()
				if i == 0 {
					item = item.Commentf("From %s", chomped).Line()
				}
				jp, adv := entry.Aspect.AsCode()
				item.ValuesFunc(func(g *jen.Group) {
					g.Line().Id("JoinPoint").Op(":").Add(jp)
					g.Line().Id("Advice").Op(":").Add(adv)
					if entry.Aspect.TracerInternal {
						g.Line().Id("TracerInternal").Op(":").Add(jen.True())
					}
					g.Line().Empty()
				})

				if depsFile != nil {
					// Make sure all necessary packages are tracked
					imports := entry.Aspect.AddedImports()
					depsFile.Anon(imports...)
					for _, path := range imports {
						injectedPaths[path] = struct{}{}
					}
				}
			}
		}
		g.Empty().Line()
	})

	file.Comment("RestorerMap is a set of import path to name mappings for packages that would be incorrectly named by restorer.Guess")
	file.Var().Id("RestorerMap").Op("=").Map(jen.String()).String().ValuesFunc(func(g *jen.Group) {
		pkgs, err := packages.Load(&packages.Config{}, "gopkg.in/DataDog/dd-trace-go.v1/...")
		if err != nil {
			log.Fatalf("Failed to load packages: %v\n", err)
		}
		sort.Sort(sortable(pkgs))

		for _, pkg := range pkgs {
			if strings.HasSuffix(pkg.PkgPath, "/internal") || strings.Contains(pkg.PkgPath, "/internal/") {
				// We don't care about internal packages here (at least for now)
				continue
			}
			if strings.HasSuffix(pkg.PkgPath, "/"+pkg.Name) {
				// We don't care about packages for which `restorer.Guess` would infer the right name.
				continue
			}
			g.Line().Lit(pkg.PkgPath).Op(":").Lit(pkg.Name)
		}

		g.Line().Empty()
	})

	file.Comment("InjectedPaths is a set of import paths that may be injected by built-in aspects.")
	file.Comment("This list is used to ensure `orchestrion warmup` includes all interesting packages.")
	file.Var().Id("InjectedPaths").Op("=").Index(jen.Op("...")).String().ValuesFunc(func(g *jen.Group) {
		paths := make([]string, 0, len(injectedPaths))
		for path := range injectedPaths {
			paths = append(paths, path)
		}
		sort.Strings(paths)
		for _, path := range paths {
			g.Line().Lit(path)
		}
		g.Line().Empty()
	})

	file.Comment("Checksum is a checksum of the built-in configuration which can be used to invalidate caches.")
	file.Const().Id("Checksum").Op("=").Lit("sha512:" + base64.StdEncoding.EncodeToString(checksum.Sum(nil)))

	if err := file.Save(output); err != nil {
		log.Fatalf("Error writing output file %q: %v\n", output, err)
	}

	if depsFile != nil {
		if err := depsFile.Save(deps); err != nil {
			log.Fatalf("Error writing output file %q: %v\n", deps, err)
		}
	}
}

type sortable []*packages.Package

func (s sortable) Len() int {
	return len(s)
}

func (s sortable) Less(i, j int) bool {
	return s[i].PkgPath < s[j].PkgPath
}

func (s sortable) Swap(i, j int) {
	s[i], s[j] = s[j], s[i]
}

func writeAll(w io.Writer, data []byte) {
	for len(data) > 0 {
		n, err := w.Write(data)
		if err != nil {
			log.Fatalf("Failed while computing checksum: %v\n", err)
		}
		data = data[n:]
	}
}

func init() {
	log.SetPrefix("github.com/DataDog/orchestrion/internal/injector/builtin/generate: ")
}

func (g *globs) Set(value string) error {
	*g = append(*g, value)
	return nil
}

func (g *globs) String() string {
	return strings.Join(*g, " ")
}

func (g *globs) glob() (files []string, err error) {
	unique := make(map[string]struct{})
	for _, pattern := range *g {
		matches, err := filepath.Glob(pattern)
		if err != nil {
			return nil, err
		}
		for _, match := range matches {
			if _, found := unique[match]; found {
				continue
			}
			unique[match] = struct{}{}
			files = append(files, match)
		}
	}

	if len(files) == 0 {
		err = fmt.Errorf("no files matched pattern(s) %s", g)
	}

	// Ensure output is sorted for determinism...
	sort.Strings(files)

	return
}

func removeLeadingSegments(path string, n int) string {
	if n <= 0 {
		return path
	}
	sep := string(filepath.Separator)
	parts := strings.Split(path, sep)
	if len(parts) <= n {
		return path
	}
	return strings.Join(parts[n:], sep)
}
