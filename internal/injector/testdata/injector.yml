%YAML 1.1
---
http-default:
  options:
    injections: &injections
      - point:
          function-body:
            function:
              - signature:
                  args:
                    - 'http.ResponseWriter'
                    - '*http.Request'
        actions:
          - add-import: github.com/datadog/orchestrion
          - prepend-statements: |-
              {{- $arg := FuncArgName 1 -}}
              {{- $name := FuncName -}}
              {{$arg}} = orchestrion.HandleHeader({{$arg}})
              orchestrion.Report({{$arg}}.Context(), orchestrion.EventStart{{with $name}}, "name", {{printf "%q" .}}{{end}}, "verb", {{$arg}}.Method)
              defer orchestrion.Report({{$arg}}.Context(), orchestrion.EventEnd{{with $name}}, "name", {{printf "%q" .}}{{end}}, "verb", {{$arg}}.Method)
  source: &httpSource |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"
      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    func handle(w http.ResponseWriter, r *http.Request) {
      data, err := io.ReadAll(r.Body)
      if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(err.Error()))
        return
      }
      defer r.Body.Close()
      w.WriteHeader(http.StatusOK)
      w.Write(data)
    }
  expected:
    modified: true
    references: &references
      github.com/datadog/orchestrion: true # Orchestrion is imported synthetically
    source: |
      package main

      import (
        "context"
        "github.com/datadog/orchestrion"
        "io"
        "log"
        "net/http"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
        //dd:startinstrument
        {
          r = orchestrion.HandleHeader(r)
          orchestrion.Report(r.Context(), orchestrion.EventStart, "name", "handle", "verb", r.Method)
          defer orchestrion.Report(r.Context(), orchestrion.EventEnd, "name", "handle", "verb", r.Method)
        }
        //dd:endinstrument
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

http-anonymous-handler:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"
      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr: ":8085",
        Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
          data, err := io.ReadAll(r.Body)
          if err != nil {
            w.WriteHeader(http.StatusBadRequest)
            w.Write([]byte(err.Error()))
            return
          }
          defer r.Body.Close()
          w.WriteHeader(http.StatusOK)
          w.Write(data)
        }),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "github.com/datadog/orchestrion"
        "io"
        "log"
        "net/http"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr: ":8085",
          Handler: http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
            //dd:startinstrument
            {
              r = orchestrion.HandleHeader(r)
              orchestrion.Report(r.Context(), orchestrion.EventStart, "verb", r.Method)
              defer orchestrion.Report(r.Context(), orchestrion.EventEnd, "verb", r.Method)
            }
            //dd:endinstrument
            data, err := io.ReadAll(r.Body)
            if err != nil {
              w.WriteHeader(http.StatusBadRequest)
              w.Write([]byte(err.Error()))
              return
            }
            defer r.Body.Close()
            w.WriteHeader(http.StatusOK)
            w.Write(data)
          }),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

http-no-arg-name:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"
      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    func handle(http.ResponseWriter, *http.Request) {
    }
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "github.com/datadog/orchestrion"
        "io"
        "log"
        "net/http"
        "orchestrion/integration"
      )

      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(_ http.ResponseWriter, _1 *http.Request) {
        //dd:startinstrument
        {
          _1 = orchestrion.HandleHeader(_1)
          orchestrion.Report(_1.Context(), orchestrion.EventStart, "name", "handle", "verb", _1.Method)
          defer orchestrion.Report(_1.Context(), orchestrion.EventEnd, "name", "handle", "verb", _1.Method)
        }
        //dd:endinstrument
      }

http-lineInfo:
  options:
    injections: *injections
    preservelineinfo: true
  source: *httpSource
  expected:
    modified: true
    references: *references
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"
        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion"
      )

      //line input.go:11
      func main() {
        s := &http.Server{
          Addr:    ":8085",
          Handler: http.HandlerFunc(handle),
        }
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
      //line <generated>:1
        //dd:startinstrument
        {
          r = orchestrion.HandleHeader(r)
          orchestrion.Report(r.Context(), orchestrion.EventStart, "name", "handle", "verb", r.Method)
          defer orchestrion.Report(r.Context(), orchestrion.EventEnd, "name", "handle", "verb", r.Method)
        }
        //dd:endinstrument
      //line input.go:23
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

http-ignored:
  options:
    injections: *injections
  source: |
    package main

    import (
      "context"
      "io"
      "log"
      "net/http"
      "orchestrion/integration"
    )

    func main() {
      s := &http.Server{
        Addr:    ":8085",
        Handler: http.HandlerFunc(handle),
      }
      integration.OnSignal(func() {
        s.Shutdown(context.Background())
      })
      log.Printf("Server shut down: %v", s.ListenAndServe())
    }

    //dd:ignore
    func handle(w http.ResponseWriter, r *http.Request) {
      data, err := io.ReadAll(r.Body)
      if err != nil {
        w.WriteHeader(http.StatusBadRequest)
        w.Write([]byte(err.Error()))
        return
      }
      defer r.Body.Close()
      w.WriteHeader(http.StatusOK)
      w.Write(data)
    }
  expected:
    modified: false

http-server:
  options:
    injections:
      - point:
          struct-literal:
            type: http.Server
            field: Handler
        actions:
          - add-import: github.com/datadog/orchestrion/instrument
          - wrap-expression: |-
              //dd:startwrap
              instrument.WrapHandler({{ Expr }})
              //dd:endwrap
    preservelineinfo: true
  source: *httpSource
  expected:
    modified: true
    references:
      github.com/datadog/orchestrion/instrument: true
    source: |
      package main

      import (
        "context"
        "io"
        "log"
        "net/http"
        "orchestrion/integration"
      //line <generated>:1
        "github.com/datadog/orchestrion/instrument"
      )

      //line input.go:11
      func main() {
        s := &http.Server{
          Addr: ":8085",
          Handler:
      //line <generated>:1
          //dd:startwrap
          instrument.WrapHandler(
      //line input.go:14
            http.HandlerFunc(handle)),
          //dd:endwrap
        }
      //line input.go:16
        integration.OnSignal(func() {
          s.Shutdown(context.Background())
        })
        log.Printf("Server shut down: %v", s.ListenAndServe())
      }

      func handle(w http.ResponseWriter, r *http.Request) {
        data, err := io.ReadAll(r.Body)
        if err != nil {
          w.WriteHeader(http.StatusBadRequest)
          w.Write([]byte(err.Error()))
          return
        }
        defer r.Body.Close()
        w.WriteHeader(http.StatusOK)
        w.Write(data)
      }

change-return-value:
  options:
    injections:
      - point:
          function-body:
            function:
              - signature:
                  returns:
                    - any
                    - error
        actions:
          - add-import: "log"
          - prepend-statements: |-
              {{- $ret := FuncReturnValue 1 -}}
              defer func(){
                if {{$ret}} != nil {
                  log.Println("error in {{FuncName}}:", {{$ret}})
                }
              }()
  source: |
    package main

    import (
      "errors"
      "log"
    )

    func test() (interface{}, error) {
      log.Println("Running test function...")
      return nil, errors.ErrUnsupported
    }
  expected:
    modified: true
    source: |
      package main

      import (
        "errors"
        "log"
      )

      func test() (_ret_0 interface{}, _ret_1 error) {
        //dd:startinstrument
        {
          defer func() {
            if _ret_1 != nil {
              log.Println("error in test:", _ret_1)
            }
          }()
        }
        //dd:endinstrument
        log.Println("Running test function...")
        return nil, errors.ErrUnsupported
      }
